<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title>GCC's new fortification level: The gains and costs</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/09/17/gccs-new-fortification-level" /><author><name>Siddhesh Poyarekar</name></author><id>aa8105eb-3693-4988-8f01-b822ce7471ee</id><updated>2022-09-17T22:00:00Z</updated><published>2022-09-17T22:00:00Z</published><summary type="html">&lt;p&gt;This article describes a new level of fortification supported in GCC. This new level detects more buffer overflows and bugs which mitigates security issues in applications at run time.&lt;/p&gt; &lt;p&gt;C programs routinely suffer from memory management problems. For several years, a &lt;code&gt;_FORTIFY_SOURCE&lt;/code&gt; preprocessor macro inserted error detection to address these problems at compile time and run time. To add an extra level of security, &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; has been in the GNU C Library (glibc) since version 2.34. I described its mechanisms in my previous blog post, &lt;a href="https://developers.redhat.com/blog/2021/04/16/broadening-compiler-checks-for-buffer-overflows-in-_fortify_source"&gt;Broadening compiler checks for buffer overflows in _FORTIFY_SOURCE&lt;/a&gt;. There has been compiler support for this builtin in &lt;a href="https://clang.llvm.org"&gt;Clang&lt;/a&gt; for some time. Compiler support has also been available for &lt;a href="https://gcc.gnu.org"&gt;GCC&lt;/a&gt; since the release of version 12 in May 2022. The new mitigation should be available in GNU/Linux distributions with packaged GCC 12.&lt;/p&gt; &lt;p&gt;The following sections discuss two principal gains from this enhanced level of security mitigation and the resulting impact on applications.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;2 principal gains:&lt;/strong&gt;&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;p&gt;Enhanced buffer size detection&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Better fortification coverage&lt;/p&gt;&lt;/li&gt; &lt;/ol&gt; &lt;h2&gt;1. A new buitin provides enhanced buffer size detection&lt;/h2&gt; &lt;p&gt;There is a new buitin underneath the new &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; macro n GCC 12 named &lt;code&gt;__builtin_dynamic_object_size&lt;/code&gt;. This builtin is more powerful than the previous &lt;code&gt;__builtin_object_size&lt;/code&gt; builtin used in &lt;code&gt;_FORTIFY_SOURCE=2&lt;/code&gt;. When passed a pointer, &lt;code&gt;__builtin_object_size&lt;/code&gt;returns as a compile-time constant that is either the maximum or minimum object size estimate of the object that pointer may be pointing to at that point in the program. On the other hand, &lt;code&gt;__builtin_dynamic_object_size&lt;/code&gt; is capable of returning a size expression that is evaluated at execution time. Consequently, the &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; builtin detects buffer overflows in many more places than &lt;code&gt;_FORTIFY_SOURCE=2&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The implementation of &lt;code&gt;__builtin_dynamic_object_size&lt;/code&gt; in GCC is compatible with &lt;code&gt;__builtin_object_size&lt;/code&gt; and thereby interchangeable, especially in the case of fortification. Whenever possible, the builtin computes a precise object size expression. When the builtin does not determine the size exactly, it returns either a maximum or minimum size estimate, depending on the size type argument.&lt;/p&gt; &lt;p&gt;This code snippet demonstrates the key advantage of returning precise values:&lt;/p&gt; &lt;pre&gt;&lt;code class="cpp"&gt;#include &lt;string.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdlib.h&gt; char *b; char buf1[21]; char *__attribute__ ((noinline)) do_set (bool cond) { char *buf = buf1; if (cond) buf = malloc (42); memset (buf, 0, 22); return buf; } int main (int argc, char **argv) { b = do_set (false); return 0; } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The program runs to completion when built with &lt;code&gt;-D_FORTIFY_SOURCE=2&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;gcc -O -D_FORTIFY_SOURCE=2 -o sample sample.c &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;But the program aborts when built with &lt;code&gt;-D_FORTIFY_SOURCE=3&lt;/code&gt; and outputs the following message:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;*** buffer overflow detected ***: terminated Aborted (core dumped) &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The key enhancement stems from the difference in behavior between &lt;code&gt;__builtin_object_size&lt;/code&gt; and &lt;code&gt;__builtin_dynamic_object_size&lt;/code&gt;. &lt;code&gt;_FORTIFY_SOURCE=2&lt;/code&gt; uses &lt;code&gt;__builtin_object_size&lt;/code&gt; and returns the maximum estimate for object size at pointer &lt;code&gt;buf&lt;/code&gt;, which is 42. Hence, GCC assumes that the &lt;code&gt;memset&lt;/code&gt; operation is safe at compile time and does not add a call to check the buffer size at run time.&lt;/p&gt; &lt;p&gt;However, GCC with &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; invokes &lt;code&gt;__builtin_dynamic_object_size&lt;/code&gt; to emit an expression that returns the precise size of the buffer that &lt;code&gt;buf&lt;/code&gt; points to at that part in the program. As a result, GCC realizes that the call to &lt;code&gt;memset&lt;/code&gt; might not be safe. Thus, the compiler inserts a call to &lt;code&gt;__memset_chk&lt;/code&gt; into the running code with that size expression as the bound for &lt;code&gt;buf&lt;/code&gt;.&lt;/p&gt; &lt;h2&gt;2. Better fortification coverage&lt;/h2&gt; &lt;p&gt;Building distribution packages with &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; revealed several issues that &lt;code&gt;_FORTIFY_SOURCE=2&lt;/code&gt; missed. Surprisingly, not all of these issues were straightforward buffer overflows. The improved fortification also encountered issues in the GNU C library (glibc) and raised interesting questions about object lifetimes.&lt;/p&gt; &lt;p&gt;Thus, the benefit of improved fortification coverage has implications beyond buffer overflow mitigation. I will explain the outcomes of &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; increased coverage in the following sections.&lt;/p&gt; &lt;h3&gt;More trapped buffer overflows&lt;/h3&gt; &lt;p&gt;Building applications with &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; detected many simple buffer overflows, such as the &lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=2115476"&gt;off-by-one access in clisp&lt;/a&gt; issue. We expected these revelations, which strengthened our justification for building applications with &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;To further support the use of &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; to improve fortification, we used the &lt;a href="https://github.com/siddhesh/fortify-metrics"&gt;Fortify metrics&lt;/a&gt; GCC plugin to estimate the number of times _FORTIFY_SOURCE=3 resulted in a call to a checking function (&lt;code&gt;__memcpy_chk&lt;/code&gt;, &lt;code&gt;__memset_chk&lt;/code&gt;, etc.). We used Fedora test distribution and some of the &lt;code&gt;Server&lt;/code&gt; package group as the sample, which consisted of 96 packages. The key metric is fortification coverage, defined by counting the number of calls to &lt;code&gt;__builtin_object_size&lt;/code&gt; that resulted in a successful size determination and the ratio of this number taken to the total number of &lt;code&gt;__builtin_object_size&lt;/code&gt; calls. The plugin also shows the number of successful calls if using &lt;code&gt;__builtin_dynamic_object_size&lt;/code&gt; instead of &lt;code&gt;__builtin_object_size&lt;/code&gt;, allowing us to infer the fortification coverage if all &lt;code&gt;__builtin_object_size&lt;/code&gt; calls were replaced with &lt;code&gt;__builtin_dynamic_object_size&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;In this short study, we found that &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; improved fortification by nearly 4 times. For example, the Bash shell went from roughly 3.4% coverage with &lt;code&gt;_FORTIFY_SOURCE=2&lt;/code&gt; to nearly 47% with &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt;. This is an improvement of nearly 14 times. Also, fortification of programs in &lt;code&gt;sudo&lt;/code&gt; went from a measly 1.3% to 49.57% — a jump of almost 38 times!&lt;/p&gt; &lt;h3&gt;The discovery of bugs in glibc&lt;/h3&gt; &lt;p&gt;The increased coverage of &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; revealed programming patterns in application programs that tripped over the fortification without necessarily a buffer overflow. While there were some bugs in glibc, we had to either explain why we did not support it or discover ways to discourage those programming patterns.&lt;/p&gt; &lt;p&gt;One example is &lt;code&gt;wcrtomb&lt;/code&gt;, where glibc makes stronger assumptions about the object size passed than POSIX allowed. Specifically, glibc assumes that the buffer passed to &lt;code&gt;wcrtomb&lt;/code&gt; is always at least &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes long. In contrast, the POSIX description makes no such assumption. Due to this discrepancy, any application that passed a smaller buffer would potentially make &lt;code&gt;wcrtomb&lt;/code&gt; overflow the buffer during conversion. Then the fortified version &lt;code&gt;__wcrtomb_chk&lt;/code&gt; aborts with a buffer overflow, expecting a buffer that is &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes long. We fixed this bug in glibc-2.36 by making glibc conform to POSIX .&lt;/p&gt; &lt;p&gt;&lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; revealed another pattern. Applications such as systemd used &lt;code&gt;malloc_usable_size&lt;/code&gt; to determine available space in objects and then used the residual space. The glibc manual discourages this type of usage, dictating that &lt;code&gt;malloc_usable_size&lt;/code&gt; is for diagnostic purposes only. But applications use the function as a hack to avoid reallocating buffers when there is space in the underlying malloc chunk. The implementation of &lt;code&gt;malloc_usable_size&lt;/code&gt; needs to be fixed to return the allocated object size instead of the chunk size in non-diagnostic use. Alternatively, another solution is to deprecate the function. But that is a topic for discussion by the glibc community.&lt;/p&gt; &lt;h3&gt;Strict C standards compliance&lt;/h3&gt; &lt;p&gt;One interesting use case exposed by &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; raised the question of object lifetimes and what developers can do with freed pointers. The bug in question was in &lt;a href="https://sourceforge.net/p/autogen/bugs/212/"&gt;AutoGen&lt;/a&gt;, using a pointer value after reallocation to determine whether the same chunk extended to get the new block of memory. This practice allowed the developer to skip copying over some pointers to optimize for performance. At the same time, the program continued using the same pointer, not the &lt;code&gt;realloc&lt;/code&gt; call result, since the old pointer did not change.&lt;/p&gt; &lt;p&gt;Seeing that the old pointer continued without an update, the compiler assumed that the object size remained the same. How could it know otherwise? The compiler then failed to account for the reallocation, resulting in an abort due to the perceived buffer overflow.&lt;/p&gt; &lt;p&gt;Strictly speaking, the C standards prohibit using a pointer to an object after its lifetime ends. It should neither be read nor dereferenced. In this context, it is a bug in the application.&lt;/p&gt; &lt;p&gt;However, this idiom is commonly used by developers to prevent making redundant copies. Future updates to &lt;a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105217"&gt;GCC&lt;/a&gt; may account for this idiom wherever possible, but applications should also explicitly indicate object lifetimes to remain compliant. In the AutoGen example, a simple fix is to unconditionally refresh the pointer after reallocation, ensuring the compiler can detect the new object size.&lt;/p&gt; &lt;h2&gt;The gains of improved security coverage outweigh the cost&lt;/h2&gt; &lt;p&gt;Building with &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; may impact the size and performance of the code. Since &lt;code&gt;_FORTIFY_SOURCE=2&lt;/code&gt; generated only constant sizes, its overhead was negligible. However, &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; may generate additional code to compute object sizes. These additions may also cause secondary effects, such as register pressure during code generation. Code size tends to increase the size of resultant binaries for the same reason.&lt;/p&gt; &lt;p&gt;We need a proper study of performance and code size to understand the magnitude of the impact created by &lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; additional runtime code generation. However the performance and code size overhead may well be worth it due to the magnitude of improvement in security coverage.&lt;/p&gt; &lt;h2&gt;The future of buffer overflow detection&lt;/h2&gt; &lt;p&gt;&lt;code&gt;_FORTIFY_SOURCE=3&lt;/code&gt; has led to significant gains in security mitigation. GCC 12 support brings those gains to distribution builds. But the new level of fortification also revealed interesting issues that require additional work to support correctly. For more background information, check out my previous article, &lt;a href="https://www.redhat.com/en/blog/enhance-application-security-fortifysource"&gt;Enhance application security with FORTIFY_SOURCE&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Object size determination and fortification remain relevant areas for improvements in compiler toolchains. The toolchain team at Red Hat continues to be involved in the GNU and LLVM communities to make these improvements.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/09/17/gccs-new-fortification-level" title="GCC's new fortification level: The gains and costs"&gt;GCC's new fortification level: The gains and costs&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Siddhesh Poyarekar</dc:creator><dc:date>2022-09-17T22:00:00Z</dc:date></entry><entry><title>My advice for updating Docker Hub's OpenJDK image</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/09/16/updating-docker-hubs-openjdk-image" /><author><name>Tim Ellison</name></author><id>3bcb8704-1585-4386-8123-ee3bcc089043</id><updated>2022-09-16T18:00:00Z</updated><published>2022-09-16T18:00:00Z</published><summary type="html">&lt;p&gt;The Java runtime environment in your containers could stop receiving updates in the coming months. It's time to take action. This article explains the decisions that led to this issue and proposes a solution.&lt;/p&gt; &lt;h2&gt;OpenJDK and Java SE updates&lt;/h2&gt; &lt;p&gt;&lt;a href="https://openjdk.org/"&gt;OpenJDK&lt;/a&gt; is an open source implementation of the Java Platform, Standard Edition (Java SE), on which multiple companies and contributors collaborate.&lt;/p&gt; &lt;p&gt;A project at OpenJDK represents each new feature release of the Java SE specification. Subsequent updates to those features, including functional and security fixes, are led by maintainers working in the &lt;a href="https://openjdk.org/projects/jdk-updates/"&gt;JDK updates project&lt;/a&gt;. Long-term supported releases such as Java SE 8 (since March 2014), Java SE 11 (since Sept 2018), and Java SE 17 (since Sept 2021) undergo a quarterly release update under the guidance of a lead maintainer.&lt;/p&gt; &lt;p&gt;The &lt;a href="https://openjdk.org/projects/jdk-updates/maintainers.html"&gt;repository maintainers' role&lt;/a&gt; is to ensure that updates are both necessary and appropriate for deployed releases. They consider the opinions of multiple contributors when making such update decisions. Many vendors and distributors of Java SE subsequently build from the OpenJDK source code to provide new releases of their own branded Java SE offerings.&lt;/p&gt; &lt;p&gt;Andrew Haley is the lead maintainer for Java 8 updates and Java 11 updates at Red Hat, and Goetz Lindenmaier (SAP) is the lead maintainer for Java 17 updates. Update maintainers affiliated with companies that provide commercially supported distributions of OpenJDK based on Java SE work as independent contributors to the project.&lt;/p&gt; &lt;h2&gt;Docker Hub deprecates OpenJDK images&lt;/h2&gt; &lt;p&gt;For many years, the official &lt;a href="https://hub.docker.com/"&gt;Docker Hub&lt;/a&gt; image builders took OpenJDK Java SE update binaries from &lt;a href="https://adoptium.net/"&gt;Eclipse Adoptium&lt;/a&gt; and other locations to build their own image. But in July 2022, the Docker Hub image builders &lt;a href="https://hub.docker.com/_/openjdk"&gt;announced the deprecation&lt;/a&gt; of this popular image.&lt;/p&gt; &lt;p&gt;Now, Docker asks users to obtain their builds of OpenJDK, either from a commercial Java vendor or directly from the Adoptium project. There will be no further updates to the existing OpenJDK image, so users risk falling behind with functional and security updates to their Java SE usage unless they move to an alternate provider. I believe the official &lt;a href="https://hub.docker.com/_/eclipse-temurin"&gt;Eclipse Temurin image&lt;/a&gt; maintained by the Adoptium project is the obvious choice for a replacement image.&lt;/p&gt; &lt;h2&gt;Eclipse Adoptium builds JDKs&lt;/h2&gt; &lt;p&gt;OpenJDK does not provide binary updates directly from the update projects. Since July 2022, these long-term supported Java update projects have depended upon &lt;a href="https://adoptium.net/"&gt;Eclipse Adoptium&lt;/a&gt; to build and distribute consumable OpenJDK binaries.&lt;/p&gt; &lt;p&gt;Adoptium is a project dedicated to building, testing, and distributing up-to-date and ready-to-use OpenJDK binaries under an open source license. Adoptium calls their builds of OpenJDK, Temurin. They are available across a broad range of processors and operating systems. These Temurin binaries have over half a billion downloads and earned the trust of enterprise production environments worldwide. A vendor-independent &lt;a href="https://adoptium.net/members"&gt;working group&lt;/a&gt; based at the Eclipse software foundation leads Adoptium.&lt;/p&gt; &lt;p&gt;The Adoptium community provides binaries built directly from OpenJDK source code. These Temurin binaries are available as direct downloads, installers, or container images and are faithful representations of the OpenJDK update source built under controlled conditions.&lt;/p&gt; &lt;p&gt;The &lt;a href="https://hub.docker.com/_/eclipse-temurin"&gt;official Docker Hub Temurin images&lt;/a&gt; contain the latest releases of the OpenJDK updates for several Java SE versions, thoroughly tested with various applications. The images work as direct drop-in replacements for the OpenJDK images. Some OpenJDK images already contain Temurin binaries.&lt;/p&gt; &lt;h2&gt;How to move from OpenJDK images to Eclipse Temurin images&lt;/h2&gt; &lt;p&gt;The Docker Hub's deprecation decision presents a problem. But there is a solution. We recommend moving from the &lt;a href="https://hub.docker.com/_/openjdk"&gt;OpenJDK image&lt;/a&gt; to &lt;a href="https://hub.docker.com/_/eclipse-temurin"&gt;the official Docker Hub Eclipse Temurin image&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;The process is simple. All you have to do is identify the &lt;code&gt;FROM&lt;/code&gt; lines in Dockerfiles such as this:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;FROM: openjdk:17&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Change the lines as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;FROM eclipse-temurin:17&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The process for changing the use of images other than version 17 is equivalent. You can &lt;a href="https://github.com/adoptium/adoptium-support/issues"&gt;report&lt;/a&gt; issues to the Adoptium community.&lt;/p&gt; &lt;h2&gt;Red Hat support&lt;/h2&gt; &lt;p&gt;We encourage everyone to switch to Eclipse Temurin. Many &lt;a href="https://github.com/jenkinsci/docker/pull/1429"&gt;application images&lt;/a&gt; and &lt;a href="https://github.com/javastacks/spring-boot-best-practice/blob/fc6709cf2ec2fc00b4dfae7210ce503f9c10560c/spring-boot-docker/Dockerfile"&gt;examples of best practices&lt;/a&gt; have successfully made the change.&lt;/p&gt; &lt;p&gt;Red Hat recently &lt;a href="https://developers.redhat.com/articles/2022/08/24/red-hat-expands-support-java-eclipse-temurin"&gt;announced direct support for Temurin&lt;/a&gt; in development and production as part of Red Hat Runtimes, Red Hat OpenShift, and Red Hat Build of OpenJDK. Red Hat support assures customers that the move to Temurin will be smooth, allowing you to continue focusing on building products that integrate and automate modern business applications and processes.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/09/16/updating-docker-hubs-openjdk-image" title="My advice for updating Docker Hub's OpenJDK image "&gt;My advice for updating Docker Hub's OpenJDK image &lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Tim Ellison</dc:creator><dc:date>2022-09-16T18:00:00Z</dc:date></entry><entry><title>Regex how-to: Quantifiers, pattern collections, and word boundaries</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/09/16/regex-how-quantifiers-pattern-collections-and-word-boundaries" /><author><name>Bob Reselman</name></author><id>2182a29a-626a-444f-a313-1e4a14d6eeb7</id><updated>2022-09-16T07:00:00Z</updated><published>2022-09-16T07:00:00Z</published><summary type="html">&lt;p&gt;Filtering and searching text with regular expressions is an important skill for every developer. Regular expressions can be tricky to master. To work with them effectively, you need a detailed understanding of their symbols and syntax.&lt;/p&gt; &lt;p&gt;Fortunately, learning to work with regular expressions can be incremental. You don't need to learn everything all at once to do useful work. Rather, you can start with the basics and then move into more complex topics while developing your understanding and using what you know as you go along.&lt;/p&gt; &lt;p&gt;This article is the second in a series. The &lt;a href="https://developers.redhat.com/articles/2022/08/03/beginners-guide-regular-expressions-grep"&gt;first article&lt;/a&gt; introduced some basic elements of regular expressions: The basic metacharacters (&lt;code&gt;.*^$\s\d&lt;/code&gt;) as well as the escape metacharacter &lt;code&gt;\&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;This article introduces some more advanced syntax: quantifiers, pattern collections, groups, and word boundaries. If you haven't read the first article, you might want to review it now before continuing with this content.&lt;/p&gt; &lt;p&gt;These articles demonstrate regular expressions by piping string output from an &lt;a href="https://www.redhat.com/sysadmin/essential-linux-commands"&gt;&lt;code&gt;echo&lt;/code&gt;&lt;/a&gt; command to the &lt;a href="https://www.redhat.com/sysadmin/how-to-use-grep"&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/a&gt; utility. The &lt;code&gt;grep&lt;/code&gt; utility uses a regular expression to filter content. The benefit of demonstrating regular expressions using &lt;code&gt;grep&lt;/code&gt; is that you don't need to set up any special programming environment. You can execute an example of a regular expression immediately by copying and pasting the code directly into your terminal window running under Linux.&lt;/p&gt; &lt;h2&gt;What's the difference between a regular character and a metacharacter&lt;/h2&gt; &lt;p&gt;A regular character is a letter, digit, or punctuation used in everyday text. When you declare a regular character in a regular expression, the regular expression engine searches content for that declared character. For example, were you to declare the regular character &lt;code&gt;h&lt;/code&gt; in a regular expression, the engine would look for occurrences of the character &lt;code&gt;h&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;A metacharacter is a placeholder symbol. For example, the metacharacter &lt;code&gt;.&lt;/code&gt; (dot) represents "any character," and means &lt;em&gt;any character matches here.&lt;/em&gt; The metacharacter &lt;code&gt;\d&lt;/code&gt; represents a numerical digit, and means &lt;em&gt;any digit matches here.&lt;/em&gt; Thus, when you use a metacharacter, the regex engine searches for characters that comply with the particular metacharacter or set of metacharacters.&lt;/p&gt; &lt;h2&gt;What are quantifiers?&lt;/h2&gt; &lt;p&gt;A quantifier is a syntactic structure in regular expressions that indicates the number of times a character occurs in sequence in the input text. There are two ways to declare a quantifier. One way is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;x{n}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this syntax:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;x&lt;/code&gt; is the character to match.&lt;/li&gt; &lt;li&gt;&lt;code&gt;n&lt;/code&gt; indicates the number of times the character needs to occur.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;A related syntax declares a quantifier with a minimum and maximum range:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;x{n,m}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this syntax:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;x&lt;/code&gt; is the character to match.&lt;/li&gt; &lt;li&gt;&lt;code&gt;n&lt;/code&gt; indicates the minimum number of occurrences and &lt;code&gt;m&lt;/code&gt; indicates the maximum number of occurrences.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The following example uses a quantifier to create a matching pattern that identifies two occurrences of the regular character &lt;code&gt;g&lt;/code&gt; in sequence:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po 'g{2}'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lucky. Gre&lt;strong&gt;gg&lt;/strong&gt; and the dog Fido. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Thus, the regular expression returns the following result:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;gg&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses a quantifier to create a matching pattern that identifies a minimum and a maximum for occurrences of the character &lt;code&gt;g&lt;/code&gt; in a sequence. The minimum length is 1 and the maximum is 2. The regular expression is processed in a case-insensitive manner, as indicated by the &lt;code&gt;-i&lt;/code&gt; option to &lt;code&gt;grep&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Poi 'g{1,2}'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lucky. &lt;strong&gt;G&lt;/strong&gt;re&lt;strong&gt;gg&lt;/strong&gt; and the do&lt;strong&gt;g&lt;/strong&gt; Fido. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Because each sequence is identified and returned on a one-by-one basis, the output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;G gg g&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;What are pattern collections?&lt;/h2&gt; &lt;p&gt;A pattern collection is a syntactic structure that describes a &lt;a href="https://www.gnu.org/software/grep/manual/html_node/Character-Classes-and-Bracket-Expressions.html"&gt;character class&lt;/a&gt;. A character class is a set of metacharacters and regular characters that combine to create a matching pattern that, like a metacharacter, can match many different characters in text. A pattern collection is defined between square brackets (&lt;code&gt;[ ]&lt;/code&gt;).&lt;/p&gt; &lt;p&gt;The following example uses the &lt;code&gt;[A-Z]&lt;/code&gt; character class, which denotes any uppercase character from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;Z&lt;/code&gt; inclusive, to create a pattern collection that matches only uppercase characters in the given text:&lt;/p&gt; &lt;p&gt;&lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '[A-Z]'&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;strong&gt;J&lt;/strong&gt;eff and the pet &lt;strong&gt;L&lt;/strong&gt;ucky. &lt;strong&gt;G&lt;/strong&gt;regg and the dog &lt;strong&gt;F&lt;/strong&gt;ido. &lt;strong&gt;C&lt;/strong&gt;hris has 1 bird named &lt;strong&gt;T&lt;/strong&gt;weety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;J L G F C T&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses the &lt;code&gt;[0-9]&lt;/code&gt; character class, which denotes any digit between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;9,&lt;/code&gt; to create a pattern collection that matches only numeric characters in the given text:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '[0-9]'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lucky. Gregg and the dog Fido. Chris has &lt;strong&gt;1&lt;/strong&gt; bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;1&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses a pattern collection that matches certain exact regular characters within a set of regular characters. The regular expression says: &lt;em&gt;Match any &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, or &lt;code&gt;F&lt;/code&gt;&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '[fGF]'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Je&lt;strong&gt;ff&lt;/strong&gt; and the pet Lucky. &lt;strong&gt;G&lt;/strong&gt;regg and the dog &lt;strong&gt;F&lt;/strong&gt;ido. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;f f G F&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses a pattern collection with both metacharacters and regular characters. The logic behind the regular expression says: &lt;em&gt;Match any &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; followed by a space character and then the string &lt;code&gt;Fido&lt;/code&gt;&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '[gre]\sFido'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lucky. Gregg and the do&lt;strong&gt;g Fido&lt;/strong&gt;. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;g Fido&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses two pattern collections along with metacharacters that are outside them. The regular expression says: &lt;em&gt;Match a numeric character, then continue matching any character zero or many times that is followed by an uppercase character&lt;/em&gt;. The pattern collection &lt;code&gt;[0-9]&lt;/code&gt; indicates any numeral from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;. The metacharacters &lt;code&gt;.*&lt;/code&gt; indicate zero or more instances of any character, and the pattern collection &lt;code&gt;[A-Z]&lt;/code&gt; indicates any uppercase character from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;Z&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '[0-9].*[A-Z]'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lucky. Gregg and the dog Fido. Chris has &lt;strong&gt;1 bird named T&lt;/strong&gt;weety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;1 bird named T&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses the negation metacharacter &lt;code&gt;^&lt;/code&gt; within a pattern collection. The negation metacharacter indicates that the succeeding characters are &lt;em&gt;not&lt;/em&gt; to be matched when the regular expression is being executed.&lt;/p&gt; &lt;p class="Indent1"&gt;&lt;strong&gt;Note&lt;/strong&gt;: As you might remember from the first article in this series, &lt;code&gt;^&lt;/code&gt; is the same metacharacter that indicates a line start—but only when used &lt;em&gt;outside&lt;/em&gt; square brackets. The &lt;code&gt;^&lt;/code&gt; metacharacter indicates negation &lt;em&gt;only&lt;/em&gt; when it appears within the square brackets (&lt;code&gt;[ ]&lt;/code&gt;) that declare a pattern collection.&lt;/p&gt; &lt;p&gt;The following collection pattern says: &lt;em&gt;Match any character that is not &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, or &lt;code&gt;u&lt;/code&gt;&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky." $ echo $teststr | grep -Po '[^aeiou]'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text. The text is underlined to make the space characters apparent:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;u&gt;&lt;strong&gt;J&lt;/strong&gt;e&lt;strong&gt;ff &lt;/strong&gt;a&lt;strong&gt;nd th&lt;/strong&gt;e&lt;strong&gt; p&lt;/strong&gt;e&lt;strong&gt;t L&lt;/strong&gt;u&lt;strong&gt;cky.&lt;/strong&gt;&lt;/u&gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Space characters in the following output are also underlined to make them apparent. Space characters are matched by this regular expression:&lt;/p&gt; &lt;pre class="language-bash"&gt; &lt;code&gt;J f f _ n d _ t h _ p t _ L c k y . &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Groups&lt;/h2&gt; &lt;p&gt;A group in a regular expression is, as the name implies, a group of characters declared according to a specific definition. A group declaration can include metacharacters and regular characters. A group is declared between open and closed parentheses like this: &lt;code&gt;( )&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The following example uses a &lt;code&gt;.&lt;/code&gt; (dot) metacharacter, which indicates "any character." The declared group says: &lt;em&gt;Match any three characters as a group and return each group&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '(...)'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in alternating bold and non-bold text as shown in the following text. Again, the text is underlined to make the space characters apparent:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;u&gt;&lt;strong&gt;Jef&lt;/strong&gt;f a&lt;strong&gt;nd &lt;/strong&gt;the&lt;strong&gt; pe&lt;/strong&gt;t L&lt;strong&gt;uck&lt;/strong&gt;y. &lt;strong&gt;Gre&lt;/strong&gt;gg &lt;strong&gt;and&lt;/strong&gt; th&lt;strong&gt;e d&lt;/strong&gt;og &lt;strong&gt;Fi&lt;/strong&gt;do. &lt;strong&gt;Chr&lt;/strong&gt;is &lt;strong&gt;has&lt;/strong&gt; 1 &lt;strong&gt;bir&lt;/strong&gt;d n&lt;strong&gt;ame&lt;/strong&gt;d T&lt;strong&gt;wee&lt;/strong&gt;ty.&lt;/u&gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Because the group is identified and returned on a one-by-one basis, the output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;Jef f_a nd_ the _pe t_L uck y._ Gre gg_ and _th e_d og_ Fid o._ Chr is_ has _1_ bir d_n ame d_T wee ty. &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses the &lt;code&gt;.&lt;/code&gt; (dot) metacharacter along with the regular character &lt;code&gt;y&lt;/code&gt; to define a group of three characters, of which the first two characters can be anything and the third character must be &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '(..y)'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lu&lt;strong&gt;cky&lt;/strong&gt;. Gregg and the dog Fido. Chris has 1 bird named Twe&lt;strong&gt;ety&lt;/strong&gt;.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;cky ety&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example demonstrates a regular expression group that uses the &lt;code&gt;.&lt;/code&gt; (dot) metacharacter along with the &lt;code&gt;\d&lt;/code&gt; metacharacter to define a group of five characters, of which the first two characters are any regular character, the third character is a digit, and the last two characters are any regular characters:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '(..\d..)'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text. The text is underlined to make the space characters apparent.&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;u&gt;Jeff and the pet Lucky. Gregg and the dog Fido. Chris ha&lt;strong&gt;s 1 b&lt;/strong&gt;ird&lt;/u&gt;&lt;/code&gt;&lt;code&gt;&lt;u&gt; named Tweety.&lt;/u&gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;strong&gt;&lt;code class="java"&gt;s&lt;u&gt; &lt;/u&gt;1&lt;u&gt; &lt;/u&gt;b&lt;/code&gt;&lt;/strong&gt;&lt;/pre&gt; &lt;h2&gt;Word boundaries&lt;/h2&gt; &lt;p&gt;A word character is declared using the metacharacters &lt;code&gt;\w&lt;/code&gt;. A word character indicates any uppercase character, lowercase character, numeric character, or connector character such as a hyphen.&lt;/p&gt; &lt;p&gt;A word boundary is defined as a transition between a word character and a beginning space, an ending space, or a punctuation mark ( &lt;code&gt;.!?&lt;/code&gt; ). A word boundary is declared using the metacharacters &lt;code&gt;\b&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The following example demonstrates a regular expression that uses the metacharacters &lt;code&gt;\w+&lt;/code&gt; to find occurrences of words within text. The metacharacter &lt;code&gt;+&lt;/code&gt; indicates one or more occurrences of a character. The logic in play is: &lt;em&gt;Match one or more word characters&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. $ echo $teststr | grep -Po '\w+'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;strong&gt;Jeff&lt;/strong&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;strong&gt;the&lt;/strong&gt; &lt;strong&gt;pet&lt;/strong&gt; &lt;strong&gt;Lucky&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Because each word is identified and returned on a one-by-one basis, the output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;Jeff and the pet Lucky&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses a word boundary to find occurrences of the regular character &lt;code&gt;a&lt;/code&gt; that appears at the beginning of a word:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;"Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '\ba'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text:&lt;/p&gt; &lt;p&gt;&lt;code&gt;and the pet Lucky. Gregg &lt;strong&gt;a&lt;/strong&gt;nd the dog Fido. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;a a&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses a word boundary to find occurrences of the regular character &lt;code&gt;y&lt;/code&gt; that appear at the end of a word:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po 'y\b'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text. Note that punctuation marks at the end of a word are not considered word characters and are excluded from the match:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;u&gt;Jeff and the pet Luck&lt;strong&gt;y&lt;/strong&gt;. Gregg and the dog Fido. Chris has 1 bird named Tweet&lt;strong&gt;y&lt;/strong&gt;.&lt;/u&gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;y y&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example uses a word boundary to find occurrences of the regular characters &lt;code&gt;Tweety&lt;/code&gt; that appear at the end of a word:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po 'Tweety\b'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text. Again, notice that punctuation marks at the end of a word are excluded:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named &lt;strong&gt;Tweety&lt;/strong&gt;.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;Tweety&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following example contains a regular expression group that uses word boundaries to find occurrences of words that start with the regular character &lt;code&gt;a&lt;/code&gt; and end with the regular character &lt;code&gt;d&lt;/code&gt;. The regular expression uses the metacharacters &lt;code&gt;\w*&lt;/code&gt; to declare all occurrences of word characters:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '\ba\w*d\b'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the characters highlighted in bold in the following text.&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff &lt;strong&gt;and&lt;/strong&gt; the pet Lucky. Gregg &lt;strong&gt;and&lt;/strong&gt; the dog Fido. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;and and&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Grouping and specifying multiple characters simultaneously extend regular expressions&lt;/h2&gt; &lt;p&gt;This article gave you an introduction to working with quantifiers, pattern collections, groups, and word boundaries. You learned to use quantifiers to declare a range of character occurrences to match. Also, you learned that pattern collections enable you to declare character classes that match characters in a generic manner. Groups execute matches that declare a particular set of characters. Word boundaries allow you to make matches by working within the boundaries of space characters and punctuation marks.&lt;/p&gt; &lt;p&gt;These intermediate concepts covered in this article will bring additional power and versatility to working regular expressions. But there's a lot more to learn. Fortunately, as mentioned at the beginning of this article, you can use the concepts and techniques discussed in this article immediately.&lt;/p&gt; &lt;p&gt;The key is to start practicing what you've learned now. Mastery is the result of small, incremental accomplishments. As with any skill, the more you practice, the better you'll get.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/09/16/regex-how-quantifiers-pattern-collections-and-word-boundaries" title="Regex how-to: Quantifiers, pattern collections, and word boundaries"&gt;Regex how-to: Quantifiers, pattern collections, and word boundaries&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Bob Reselman</dc:creator><dc:date>2022-09-16T07:00:00Z</dc:date></entry><entry><title type="html">New Keycloak maintainer: Michal Hajas</title><link rel="alternate" href="https://www.keycloak.org/2022/09/mhajas" /><author><name>Stian Thorgersen</name></author><id>https://www.keycloak.org/2022/09/mhajas</id><updated>2022-09-16T00:00:00Z</updated><content type="html">We are pleased to welcome as an official maintainer of Keycloak. Michal has been with the Keycloak project since September 2015, and since that period has to almost every component of Keycloak - core server, authorization services, adapters, javascript, code auto-generation, legacy operator - either by review or code contribution. Since his first involvement, he has steadily contributed code, currently . Lately, he has designed and co-developed Hot Rod storage and has been instrumental in overall establishing the new map storage. He reviews community contributions and offers help to finalize PRs, as well as participates in community discussions and issue triaging. He understands and respects the code of conduct, and in reviews helps maintaining it.</content><dc:creator>Stian Thorgersen</dc:creator></entry><entry><title type="html">Multiple repositories Pull Request chaos, crawl them all in one single place</title><link rel="alternate" href="https://blog.kie.org/2022/09/multiple-repositories-pull-request-chaos-crawl-them-all-in-one-single-place.html" /><author><name>Enrique Mingorance Cano</name></author><id>https://blog.kie.org/2022/09/multiple-repositories-pull-request-chaos-crawl-them-all-in-one-single-place.html</id><updated>2022-09-15T17:00:00Z</updated><content type="html">Flickr chaos – https://bit.ly/3Q2zfYS It is very frequent to find software engineering projects where multiple repositories are involved for the same or different projects, somehow related between them, a lot of people push their pull requests to any of them and it is very normal to lose tracking of the situation or you have to constantly browse them all to have a clearer picture about what is going on. That’s the situation we had here at the Red Hat Business Automation team and we solved it by creating a helpful tool you can easily use for your set of projects, easy, quick and for free. THE CROSS-REPO PRS PROBLEM This is already covered by entry, so feel free to read it in case you are not familiar with this kind of situation or concepts. THE CHAIN-STATUS SOLUTION So we said to ourselves, what if we would have a centralized place, a web page for instance, to be able to see in a quick look what’s the situation about all the pull requests for all of our repositories? was the solution. Prerequisites: * It has to solve not only our particular problem, so anyone can use it. * It has to be public, no authentication required. * It has to be fast, we can’t wait for the whole pull request set to be crawled everytime anyone gets into the application. * Multiple streams or different project set can be handled in different views, like different products or product versions from the same place. * The content can be filtered out. So the conclusion was to create in one hand a React web page to consume the pull request information from a static report and another tool to generate that report based on Github information. This way: * The information will be produced asynchronously, the frequency will be up to the user/developer and Github API rate limit problems will be avoided. * The information can be taken even from private repositories and be exposed publicly and no authentication will be required.  * No waiting time while information is requested from Github service. * The webpage (HTML+JS files) can be stored on any web service, even on free services like or . * No backend server is required. RUNNING EXAMPLE You can check KIE RHBA status web page at Chain Status web tool screenshot HOW CAN I ADD IT TO MY ORGANIZATION? The best way to integrate this tool in your organization or set of repositories is by using the provided configurable . In particular this tool comes with two main easy-to-use : * Generate App: this action aims to build and copy the React web application inside your repository and publish it using NPM tool. * Generate Data: given a project structure and some project information as input, this action is focused on generating the data report gathering the information using the Github API. This report is then used by the web application as a content source. Thus, in order to use these actions on your organization, you only have to add two (one per action) on your main repository as follows: 1. Prerequisites: having a Github token properly configured in your organization, on how to configure it. 2. Generate app workflow (generate_status_page.yaml): add the Github workflow for the web page generation, this should generally be run only once (or whenever there are changes on the web app look and feel). name: Generate status page on: workflow_dispatch jobs:   generate-status-page:     if: github.repository_owner == '&lt;OWNER&gt;'     concurrency:       group: generate-status-page       cancel-in-progress: true     strategy:       matrix:         os: [ubuntu-latest]       fail-fast: true     runs-on: ubuntu-latest     name: Generate status page     steps:       - name: Generate status page         uses: kiegroup/chain-status/.ci/actions/generate-app@main         with:           info-md-url: "&lt;PATH-TO-INFO&gt;"           github-token: "${{ secrets.GITHUB_TOKEN }}"           gh-pages-branch: "gh-pages" 3. Generate data workflow (generate_status_page_data.yaml): add the periodic workflow that will continuously generate the data fetched by the web application. name: Generate status page data on:   workflow_dispatch:   schedule:     - cron: '0 * * * *' jobs:   generate-status-page-data:     if: github.repository_owner == '&lt;OWNER&gt;'     concurrency:       group: generate-status-page-data       cancel-in-progress: true     strategy:       matrix:         os: [ubuntu-latest]       fail-fast: true     runs-on: ubuntu-latest     name: Generate status page data     steps:       - name: Generate status page data         uses: kiegroup/chain-status/.ci/actions/generate-data@main         with:           definition-file: &lt;PATH-TO-DEFINITION-FILE&gt;           # projects: &lt;PROJECTS-LIST&gt;           title: &lt;TITLE&gt;           subtitle: &lt;SUBTITLE&gt;           base-branch-filter: &lt;BRANCH-LIST&gt;           created-by: Github Action           created-url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}           logger-level: debug           github-token: "${{ secrets.GITHUB_TOKEN }}"           gh-pages-branch: "gh-pages"  As already introduced, the generate data flow relies on a project structure definition which can be provided either using build-chain definition file or a projects list: * Build-chain definition file (using ‘definition-file’ field), a YAML definition file for cross-related inter-dependent projects which was introduced for . This tool is already covered by , so feel free to read it if you want to get more details on it and on its definition files. * Projects list (using ‘projects’ field), a comma-separated list of projects for which you would like to provide Pull Requests statuses. [Still a Work in Progress ] This was a brief explanation on how you could integrate this tool in your organization, if you need more details on this feel free to reach the homepage, where you can find a step-by-step guide on how to integrate it with some links to running examples. ADDITIONAL FUNCTIONALITIES Additionally to the pull request summary functionality, it is also possible to add multiple Jenkins status reports. The main advantage of this feature is that you can check the status of all your Jenkins jobs in a single place, making it easier to check what runs succeeded/failed and also the time and average time jobs are consuming. As an example you can check the KIE RHBA daily builds page   To configure the Jenkins status reports feature, you can create a Jenkins pipeline that will generate and update the data periodically. You can schedule the Jenkins pipeline to run and keep the status updated based on your required demand. You can add the following steps as part of your Jenkins pipeline to generate and update the status report: 1. Clone the GitHub pages repository stage('Clone gh-pages repository') {   steps {     script {       println "Checking out https://github.com/${ghPagesRepository}:${ghPagesBranch} into ${ghPagesRepoFolder} folder"       sh "git clone -b ${ghPagesBranch} --single-branch https://github.com/${ghPagesRepository} ${ghPagesRepoFolder}"     }   } } 2. Install the chain-status tool stage('Install chain-status tool') {   steps {     script {       try {         sh "npm install -g @kie/chain-status-action"       } catch(e) {         println '[WARNING] Error installing @kie/chain-status-action.'       }     }   } } 3. Generate the updated data stage('Generate data') {   steps {     script {       dir(ghPagesRepoFolder) {         sh "build-chain-status-report --jenkinsUrl ${jenkinsURL} --jobUrl ${jenkinsJobPath} -t ${projectTitle} -st ${projectSubtitle} --certFilePath ${jenkinsCertFile} --outputFolderPath ./data/ --skipZero -cb \"Jenkins Job\" -cu \"${env.BUILD_URL}\" --order 1001"       }     }   } } 4. Push changes to update the status report stage('Push changes to repository') {   steps {     script {       println "Pushing changes to ${ghPagesRepository}:${ghPagesBranch}"         dir(ghPagesRepoFolder) {           withCredentials([usernamePassword(credentialsId: "${githubCredentialsId}", usernameVariable: 'GITHUB_USER', passwordVariable: 'GITHUB_TOKEN')]) { githubscm.setUserConfig("${GITHUB_USER}")           sh("git config --local credential.helper \"!f() { echo username=\\$GITHUB_USER; echo password=\\$GITHUB_TOKEN; }; f\"")           sh 'git add data/*'           sh 'git commit -m "Generate Jenkins Data"'           sh "git push origin ${ghPagesBranch}"                                   }       }     }   } } NEXT STEPS AND LIMITATIONS HISTORIC FUNCTIONALITY Since the generator tool registers every day status, we expect to offer the historic view functionality to be able to compare status between dates.See TO COVER NOT ONLY GITHUB BUT OTHER REPOSITORY SERVICES Right now we only cover Github for the generator tool to take information from, but we expect to cover another kind of services like Gitlab or Bitbucket. CONCLUSION We have been using this tool for , and repositories for a year and we can say it’s a very useful tool which solves the cross-repo pull requests summary problem. After a year of experience with the tool we can say the tool offers: * To be able to constantly see the status of the different contributions from the different people. * Who is working on what, like which are my own open pull requests. * To quickly check obsolete contributions and to be able to keep our repositories very clean. * To publicly offer Jenkins jobs summary no matter whether the Jenkins is accessible or not. * To quickly check how healthy our CI/CD stuff is thanks to the error index information from the tool. * To be able to see related pull requests for every pull request, thanks to the cross-repo pull request functionality. USEFUL LINKS [Chain status]   [Build chain tool] [Build chain npm package]   [Configuration reader] [RHBA definition and project tree files]  [RHBA flows]   Featured photo by The post appeared first on .</content><dc:creator>Enrique Mingorance Cano</dc:creator></entry><entry><title>How to implement a job queue with Redis</title><link rel="alternate" href="&#xA;                https://quarkus.io/blog/redis-job-queue/&#xA;            " /><author><name>Clement Escoffier (https://twitter.com/clementplop)</name></author><id>https://quarkus.io/blog/redis-job-queue/</id><updated>2022-09-15T00:00:00Z</updated><published>2022-09-15T00:00:00Z</published><summary type="html">In how to cache with Redis, we implemented a simple cache backed by Redis. That’s just one use case of Redis. Redis is also used as a messaging server to implement the processing of background jobs or other kinds of messaging tasks. This post explores implementing this pattern with Quarkus...</summary><dc:creator>Clement Escoffier (https://twitter.com/clementplop)</dc:creator><dc:date>2022-09-15T00:00:00Z</dc:date></entry><entry><title type="html">Getting started with Jakarta RESTful Services</title><link rel="alternate" href="http://www.mastertheboss.com/jboss-frameworks/resteasy/getting-started-with-jakarta-restful-services/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/jboss-frameworks/resteasy/getting-started-with-jakarta-restful-services/</id><updated>2022-09-14T16:44:00Z</updated><content type="html">The latest release of RESTEasy (6.1.0) provides an implementation for Jakarta RESTful Web Services 3.1. which is a core component of Jakarta EE 10. Let’s review through this article which are the core features of Jakarta Rest Services. What’s new in Jakarta RESTful Web Services 3.1 The Jakarta RESTful Web Services 3.1 specification (part of ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>A beginner’s guide to regular expressions with grep</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/09/14/beginners-guide-regular-expressions-grep" /><author><name>Bob Reselman</name></author><id>d2745cb9-0e7f-4c18-88b2-a5ce98fb99ac</id><updated>2022-09-14T07:00:00Z</updated><published>2022-09-14T07:00:00Z</published><summary type="html">&lt;p&gt;A &lt;em&gt;regular expression&lt;/em&gt; (also called a &lt;em&gt;regex&lt;/em&gt; or &lt;em&gt;regexp&lt;/em&gt;) is a rule that a computer can use to match characters or groups of characters within a larger body of text. For instance, using regular expressions, you could find all the instances of the word &lt;em&gt;cat&lt;/em&gt; in a document, or all instances of a word that begins with &lt;em&gt;c&lt;/em&gt; and ends with &lt;em&gt;t.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Use of regular expressions in the real world can get much more complex—and powerful—than that. For example, imagine you need to write code verifying that all content in the body of an HTTP POST request is free of script injection attacks. Malicious code can appear in any number of ways, but you know that injected script code will always appear between &lt;code&gt;&lt;script&gt;&lt;/script&gt;&lt;/code&gt; HTML tags. You can apply the regular expression &lt;code&gt;&lt;script&gt;.*&lt;\/script&gt;&lt;/code&gt;, which matches any block of code text bracketed by &lt;code&gt;&lt;script&gt;&lt;/code&gt; tags, to the HTTP request body as part of your search for script injection code.&lt;/p&gt; &lt;p&gt;This example is but one of many uses for regular expressions. In this series, you'll learn more about how the syntax for this and other regular expressions work.&lt;/p&gt; &lt;p&gt;As just demonstrated, a regex can be a powerful tool for finding text according to a particular pattern in a variety of situations. Once mastered, regular expressions provide developers with the ability to locate patterns of text in source code and documentation at design time. You can also apply regular expressions to text that is subject to algorithmic processing at runtime such as content in HTTP requests or event messages.&lt;/p&gt; &lt;p&gt;Regular expressions are supported by many programming languages, as well as classic command-line applications such as &lt;a href="https://www.redhat.com/sysadmin/linux-text-manipulation-tools"&gt;awk, sed, and grep&lt;/a&gt;, which were developed for Unix many decades ago and are now offered on GNU/Linux.&lt;/p&gt; &lt;p&gt;This article examines the basics of using regular expressions under &lt;code&gt;grep&lt;/code&gt;. The article shows how you can use a regular expression to declare a pattern that you want to match, and outlines the essential building blocks of regular expressions, with many examples. This article assumes no prior knowledge of regular expressions, but you should understand how to with the &lt;a href="https://developers.redhat.com/topics/linux"&gt;Linux&lt;/a&gt; operating system at the command line.&lt;/p&gt; &lt;h2&gt;What are regular expressions, and what is grep?&lt;/h2&gt; &lt;p&gt;As we've noted, a regular expression is a rule used for matching characters in text. These rules are &lt;em&gt;declarative,&lt;/em&gt; which means they are immutable: once declared, they do not change. But a single rule can be applied to any variety of situations.&lt;/p&gt; &lt;p&gt;Regular expressions are written in a special language. Although this language has been standardized, dialects vary from one regular expression engine to another. For example, &lt;a href="https://developers.redhat.com/topics/javascript"&gt;JavaScript&lt;/a&gt; has a regex dialect, as do &lt;a href="https://developers.redhat.com/topics/c"&gt;C++&lt;/a&gt;, &lt;a href="https://developers.redhat.com/java"&gt;Java&lt;/a&gt;, and &lt;a href="https://developers.redhat.com/topics/python"&gt;Python&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;This article uses the regular expression dialect that goes with the Linux &lt;a href="https://www.redhat.com/sysadmin/how-to-use-grep"&gt;grep&lt;/a&gt; command, with an extension to support more powerful features. &lt;code&gt;grep&lt;/code&gt; is a binary executable that filters content in a file or output from other commands (stdout). Regular expressions are central to &lt;code&gt;grep&lt;/code&gt;: The &lt;em&gt;re&lt;/em&gt; in the middle of the name stands for "regular expression."&lt;/p&gt; &lt;p&gt;This article uses &lt;code&gt;grep&lt;/code&gt; because it doesn't require that you set up a particular coding environment or write any code to work with the examples of regular expressions demonstrated in this article. All you need to do is copy and paste an example onto the command line of a Linux terminal and you'll see results immediately. The &lt;code&gt;grep&lt;/code&gt; command can be used in any shell.&lt;/p&gt; &lt;p&gt;Because this article focuses on regular expressions as a language, and not on manipulating files, the examples use samples of text piped to &lt;code&gt;grep&lt;/code&gt; instead of input files.&lt;/p&gt; &lt;h3&gt;How to use grep against content in a file&lt;/h3&gt; &lt;p&gt;To print lines in a file that match a regular expression, use the following syntax:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ grep -options &lt;regular_expression&gt; /paths/to/files&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this command syntax:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;-options&lt;/code&gt;, if specified, control the behavior of the command.&lt;/li&gt; &lt;li&gt;&lt;code&gt;&lt;regular_expression&gt;&lt;/code&gt; indicates the regular expression to execute against the files.&lt;/li&gt; &lt;li&gt;&lt;code&gt;/paths/to/files&lt;/code&gt; indicate one or more files against which the regular will be executed.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The options used in this article are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;-P&lt;/code&gt;: Apply regular expressions in the style of the Perl programming language. This option, which is specific to GNU/Linux, is used in the article to unlock powerful features that aren't recognized by &lt;code&gt;grep&lt;/code&gt; by default. There is nothing specific to Perl in the regular expressions used in this article; the same features can be found in many programming languages.&lt;/li&gt; &lt;li&gt;&lt;code&gt;-i&lt;/code&gt;: Match in a case-insensitive manner.&lt;/li&gt; &lt;li&gt;&lt;code&gt;-o&lt;/code&gt;: Print only the characters matching the regular expression. By default, the whole line containing the matching string is printed.&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;How to pipe content to a regular expression&lt;/h3&gt; &lt;p&gt;As mentioned earlier, you can also use a regular expression to filter output from stdout. The following example uses the pipe symbol (&lt;code&gt;|&lt;/code&gt;) to feed the result of an &lt;code&gt;echo&lt;/code&gt; command to &lt;code&gt;grep&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ echo "I like using regular expressions." | grep -Po 'r.*ar'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The command produces the following output:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;regular&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Why does &lt;code&gt;grep&lt;/code&gt; return the characters &lt;code&gt;regular&lt;/code&gt; to match the regular expression specified here? We'll explore the reasons in subsequent sections of this article.&lt;/p&gt; &lt;h2&gt;Regular characters, metacharacters, and patterns: The building blocks of regular expressions&lt;/h2&gt; &lt;p&gt;You'll use three basic building blocks when working with regular expressions: &lt;em&gt;regular characters, metacharacters,&lt;/em&gt; and &lt;em&gt;patterns.&lt;/em&gt; Regular characters and metacharacters are used to create a regular expression, and that regular expression represents a matching pattern that the regex engine applies to some content.&lt;/p&gt; &lt;p&gt;You can think of a metacharacter as a placeholder symbol. For example, the &lt;code&gt;.&lt;/code&gt; metacharacter (a dot or period) represents "any character." The &lt;code&gt;\d&lt;/code&gt; metacharacter represents any single numeral, 0 through 9.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;*&lt;/code&gt; metacharacter is a shorthand that represents the instruction "search for a character that occurs zero or more times as defined by the preceding character." (You'll see how to work with the &lt;code&gt;*&lt;/code&gt; metacharacter in sections to come.)&lt;/p&gt; &lt;p&gt;Regular expressions support many metacharacters, each worthy of a page or two of description. For now, the important thing to understand is that a metacharacter is a reserved symbol used by the regex engine to describe a character in a generic manner. Also, certain metacharacters are a shorthand for a search instruction.&lt;/p&gt; &lt;p&gt;You can combine regular characters with metacharacters to declare rules that define search patterns. For example, consider the following short regular expression:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;.t&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This matches a pattern consisting of two characters. The first character can be any character, as declared by the &lt;code&gt;.&lt;/code&gt; (dot) metacharacter, but the second character must be &lt;code&gt;t&lt;/code&gt;. Thus, applying the regular expression &lt;code&gt;.t&lt;/code&gt; to the string &lt;code&gt;I like cats but not rats&lt;/code&gt; matches the strings highlighted in bold font here:&lt;/p&gt; &lt;p&gt;&lt;code&gt;I like c&lt;strong&gt;at&lt;/strong&gt;s b&lt;strong&gt;ut&lt;/strong&gt; n&lt;strong&gt;ot&lt;/strong&gt; r&lt;strong&gt;at&lt;/strong&gt;s&lt;/code&gt;&lt;/p&gt; &lt;p&gt;You can do a lot using just the basic metacharacters to create regular expressions with &lt;code&gt;grep&lt;/code&gt;. The following sections provide a number of useful examples.&lt;/p&gt; &lt;h2&gt;Running basic regular expressions&lt;/h2&gt; &lt;p&gt;The following subsections demonstrate various examples of regular expressions. The examples are presented as two commands to enter in a Linux terminal. The first command creates a variable named &lt;code&gt;teststr&lt;/code&gt; that contains a sample string. The second executes the &lt;code&gt;echo&lt;/code&gt; command against &lt;code&gt;teststr&lt;/code&gt; and pipes the result of the &lt;code&gt;echo&lt;/code&gt; command to &lt;code&gt;grep&lt;/code&gt;. The &lt;code&gt;grep&lt;/code&gt; command then filters the input according to the associated regular expression.&lt;/p&gt; &lt;h3&gt;How to declare an exact pattern match using regular characters&lt;/h3&gt; &lt;p&gt;The following example demonstrates how to search a string according to the pattern of regular characters, &lt;code&gt;Fido&lt;/code&gt;. The search declaration is case-sensitive:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po 'Fido'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The result is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;Fido&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;How to declare a case-insensitive exact pattern match&lt;/h3&gt; &lt;p&gt;The following example demonstrates how to search a string according to a pattern of regular characters, &lt;code&gt;fido&lt;/code&gt;. The search declaration is case-insensitive, as indicated by the &lt;code&gt;-i&lt;/code&gt; option in the &lt;code&gt;grep&lt;/code&gt; command. Thus, the regex engine will find occurrences such as &lt;code&gt;FIDO&lt;/code&gt; as well as &lt;code&gt;fido&lt;/code&gt; or &lt;code&gt;fiDo&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Poi 'fido'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The result is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;Fido&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;How to declare a logical pattern match&lt;/h3&gt; &lt;p&gt;The following example uses the &lt;code&gt;|&lt;/code&gt; metacharacter symbol to search according to a &lt;em&gt;this or that&lt;/em&gt; condition—that is, a condition that can be satisfied by either of the regular expressions on either side of &lt;code&gt;|&lt;/code&gt;. In this case, the regular expression matches occurrences of the regular character &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;g&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po 'f|g'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;grep&lt;/code&gt; command identifies each occurrence that satisfies the rule declared in the regular expression. Conceptually, the regular expression is saying, &lt;em&gt;Return any character that is either an f or a g&lt;/em&gt;. We are leaving the search case-sensitive, as is the default. Thus, the identified characters are highlighted in bold text here:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Je&lt;strong&gt;ff&lt;/strong&gt; and the pet Lucky. Gre&lt;strong&gt;gg&lt;/strong&gt; and the do&lt;strong&gt;g&lt;/strong&gt; Fido. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Because each character is identified and returned on a one-by-one basis, the output sent to the terminal window is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;f f g g g&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;How to find a character at the beginning of a line&lt;/h3&gt; &lt;p&gt;The following example uses the &lt;code&gt;^&lt;/code&gt; metacharacter to search for the beginning of a line of text. Conceptually, the &lt;code&gt;^&lt;/code&gt; metacharacter matches the beginning of a line.&lt;/p&gt; &lt;p&gt;The example executes the regular expression &lt;code&gt;^J&lt;/code&gt;. This regular expression searches for a match that satisfies two conditions. The first condition is to find the beginning of the line; the next is to find the regular character &lt;code&gt;J&lt;/code&gt; at that position.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '^J'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the character highlighted in bold text as shown here:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;strong&gt;J&lt;/strong&gt;eff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety.&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The result returned to the terminal is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;J&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;How to find a character at the end of a line&lt;/h3&gt; &lt;p&gt;The following example uses the &lt;code&gt;$&lt;/code&gt; metacharacter to search for the end of a line to text.&lt;/p&gt; &lt;p&gt;The example executes the regular expression &lt;code&gt;\.$&lt;/code&gt;. The regular expression declares a matching rule that has two conditions. First, the regular expression searches for an occurrence of the regular character &lt;code&gt;.&lt;/code&gt; (dot). Then the regular expression looks to see whether the end of the line is next. Thus, if the &lt;code&gt;.&lt;/code&gt; character comes at the end of the line, it's deemed a match.&lt;/p&gt; &lt;p&gt;The regular expression includes a backslash (&lt;code&gt;\&lt;/code&gt;) as an "escape" metacharacter before the dot. The escape metacharacter is needed to override the normal meaning of the dot as a metacharacter. Remember that the &lt;code&gt;.&lt;/code&gt; (dot) metacharacter means &lt;em&gt;any character&lt;/em&gt;. With the escape character, the dot is treated as a regular character, and so matches just itself:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po '\.$'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The regular expression matches the final dot in the text, highlighted in bold as shown here:&lt;/p&gt; &lt;p&gt;&lt;code&gt;Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety&lt;strong&gt;.&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The result is just the final dot:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;.&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Suppose you were to use an unescaped dot in the regular expression:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ echo $teststr | grep -Po '.$'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You would get the same result as using the escaped dot, but a different logic is being executed. That logic is: &lt;em&gt;Match any character that is the last character before the end of the string&lt;/em&gt;. Thus, the regular expression would always match any line. Using the escape character to identify a character as a regular character is a subtle distinction in this case, but an important one nonetheless.&lt;/p&gt; &lt;h3&gt;How to find multiple characters at the end of a line&lt;/h3&gt; &lt;p&gt;The following example searches the string assigned to the variable &lt;code&gt;teststr&lt;/code&gt; to match the characters &lt;code&gt;ty.&lt;/code&gt; when they appear at the end of a line.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="Jeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety." $ echo $teststr | grep -Po 'ty\.$'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The result is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;ty.&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Again, note the user of the escape metacharacter (&lt;code&gt;\&lt;/code&gt;) to declare the &lt;code&gt;.&lt;/code&gt; (dot) character as a regular character.&lt;/p&gt; &lt;h3&gt;How to find occurrences of a character using the metacharacters for matching numerals&lt;/h3&gt; &lt;p&gt;The following example uses the &lt;code&gt;\d&lt;/code&gt; metacharacter to create a regular expression that looks for matches of any numeral in a given piece of text.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="There are 9 cats and 2 dogs in a box." $ echo $teststr | grep -Po '\d'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Because each numeral is matched and returned on a one-by-one basis, the output sent to the terminal is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;9 2&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;How to find a string using metacharacters for a numeral and a space&lt;/h3&gt; &lt;p&gt;The following example uses the &lt;code&gt;\d &lt;/code&gt;and &lt;code&gt;\s&lt;/code&gt; metacharacters along with regular characters to create a regular expression that matches text according to the following logic: &lt;em&gt;Match any numeral that is followed by a space and then the regular characters &lt;/em&gt;&lt;strong&gt;&lt;em&gt;cats&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;\d&lt;/code&gt; metacharacter matches a numeral and the &lt;code&gt;\s&lt;/code&gt; metacharacter matches a whitespace character (a space, a tab, or a few other rare characters):&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="There are 9 cats and 2 dogs in a box." $ echo $teststr | grep -Po '\d\scats'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The result is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;9 cats&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;How to combine metacharacters to create a complex regular expression&lt;/h3&gt; &lt;p&gt;The following example uses the &lt;code&gt;\d&lt;/code&gt; metacharacter to match a numeral, &lt;code&gt;\s&lt;/code&gt; to match a space, and &lt;code&gt;.&lt;/code&gt; (dot) to match any character. The regular expressions uses the &lt;code&gt;*&lt;/code&gt; metacharacter to say, &lt;em&gt;Match zero or more successive occurrences of the preceding character.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;The logic expressed in the regular expression is this: &lt;em&gt;Find a string of text that starts with a numeral followed by a space character and the regular characters &lt;strong&gt;cats.&lt;/strong&gt; Then keep going, matching any characters until you come to another numeral followed by a space character and the regular characters &lt;strong&gt;dogs&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="There are 9 cats and 2 dogs in a box." $ echo $teststr | grep -Po '\d\scats.*\d\sdogs'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The result is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;9 cats and 2 dogs&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;How to traverse a line of text to a stop point&lt;/h3&gt; &lt;p&gt;The following example uses the &lt;code&gt;.&lt;/code&gt; (dot) metacharacter and &lt;code&gt;*&lt;/code&gt; along with the regular characters &lt;code&gt;cats&lt;/code&gt; to create a regular expression with the following logic: &lt;em&gt;Match any character zero or more times until you come to the characters &lt;strong&gt;cats&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ teststr="There are 9 cats and 2 dogs in a box." $ echo $teststr | grep -Po '.*cats'&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The result is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;There are 9 cats&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The interesting thing about this regular expression is that starting from the beginning of the line is implicit. The &lt;code&gt;^&lt;/code&gt; metacharacter could be used to indicate the start of a line, but because the regular expression matches any characters until you come to &lt;code&gt;cats&lt;/code&gt;, it isn't necessary to explicitly declare the start of the line using &lt;code&gt;^&lt;/code&gt;. The regular expression starts processing from the beginning of the line by default.&lt;/p&gt; &lt;h2&gt;Regular expressions uncover patterns in text&lt;/h2&gt; &lt;p&gt;Regular expressions offer a powerful yet concise way to do complex text filtering. You can use them in programming languages such as JavaScript, Python, Perl, and C++, and directly in a Linux terminal to process files and text using the &lt;code&gt;grep&lt;/code&gt; command, as demonstrated in this article.&lt;/p&gt; &lt;p&gt;Getting the hang of regular expressions takes time. Mastering the intricacies of working with the metacharacters alone can be daunting. Fortunately, the learning curve is developmental. You don't have to master the entirety of regular expressions to work with them usefully as a beginner. You can start with the basics, and as you learn more you can do more. Just being able to do pattern matching using the basic examples shown in this article can provide immediate benefit.&lt;/p&gt; &lt;p&gt;An upcoming article in this series will explain regular expression features that are even more powerful.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/09/14/beginners-guide-regular-expressions-grep" title="A beginner’s guide to regular expressions with grep"&gt;A beginner’s guide to regular expressions with grep&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Bob Reselman</dc:creator><dc:date>2022-09-14T07:00:00Z</dc:date></entry><entry><title type="html">Remote dev-watch development with WildFly Jar Maven Plugin</title><link rel="alternate" href="https://wildfly.org//news/2022/09/14/Remote-dev-watch/" /><author><name>Emmanuel Hugonnet</name></author><id>https://wildfly.org//news/2022/09/14/Remote-dev-watch/</id><updated>2022-09-14T00:00:00Z</updated><content type="html">The 8.0.0.Alpha2 version of the has been released. This is not yet Final, as it is only there to gather feedback on a new feature that simplifies development on the "cloud" using the dev-watch goal. For people who are not familiar with WildFly bootable JAR and its dev-watch goal, I strongly recommend that you read this that covers it in details. DEV-WATCH GOAL The current dev-watch goal, although offering an efficient workflow to develop WildFly applications, requires the bootable application or server to run locally, in the same place as the project. The improvement made on this release is to allow the bootable application or server to run remotely so that it can be in an environment that is closer to the target runtime environment. We are going to use to see how we can work remotely. Important This application applies the script anonymous-management.cli which disable security on the Management API of WildFly, please make sure not to include it when going to production. DEVELOPPING WITH A DOCKER CONTAINER. BUILD AND RUN THE APPLICATION WITH DOCKER The first step is to create the container image where the application is running. For this we are going to use a very simple Dockerfile: FROM registry.access.redhat.com/ubi8/openjdk-11:latest COPY --chown=jboss:root target/*.jar /deployments/. RUN chmod -R ug+rwX /deployments/. To build that container image we are executing: $ mvn clean install $ podman build -f Dockerfile -t remote-microprofile-config:latest And then we are going to run the container and expose the ports 8080 and 9990: $ podman run -p 8080:8080 -p 9990:9990 -it remote-microprofile-config:latest DEVELOP AND UPDATE THIS APPLICATION Now we need to run the dev-watch goal and remotely attach to the Wildfly Management API. For this we need to execute the following command line: $ mvn org.wildfly.plugins:wildfly-jar-maven-plugin:8.0.0.Alpha2:dev-watch \ -Dwildfly.bootable.remote=true \ -Dwildfly.bootable.remote.username=admin \ -Dwildfly.bootable.remote.password=passW0rd! \ -Dwildfly.hostname=${container.ip.address} Check that the application is running properly : $ curl http://${container.ip.address}:8080 config1 = Value from Config1 comes from an env var in the DeploymentConfig config2 = Value for config2 comes from a properties file inside the application config3 = Default value for config3 comes from my code Once this is done you can edit the code and your changes will be automatically pushed to the remote container. For example: * Change the config2 property value to be "Hello from dev-watch remote" in the file: src/main/resources/META-INF/microprofile-config.properties. * Save your changes * The application is redeployed and the new configuration will be taken into account: $ curl http://${container.ip.address}:8080 config1 = Value from Config1 comes from an env var in the DeploymentConfig config2 = Hello from dev-watch remote config3 = Default value for config3 comes from my code DEVELOPPING ON OPENSHIFT. BUILD AND RUN THE APPLICATION WITH OPENSHIFT We first need to build the application : $ mvn clean install Then to deploy it you need to drag and drop the produced remote-microprofile-config-bootable.jar on the Topology page on OpenShift. Now we need to expose the management API of WilFly by first editing the service to add a TCP port for 9990, and then add a route to that port: $ oc create route edge management-remote-microprofile-config-bootable --service=remote-microprofile-config-bootable --port=9990 --insecure-policy='Redirect' DEVELOP AND UPDATE THIS APPLICATION Now we need to run the dev-watch goal and remotely attach to the Wildfly Management API. For this we need to execute the following command line: $ mvn -P bootable-jar-remote -Dwildfly.hostname=$(oc get route management-remote-microprofile-config-bootable --template='{{ .spec.host }}') install You may also use a command like this one: $ mvn org.wildfly.plugins:wildfly-jar-maven-plugin:8.0.0.Alpha2:dev-watch \ -Dwildfly.bootable.remote=true \ -Dwildfly.port=443 \ -Dwildfly.bootable.remote.protocol=remote+https \ -Dwildfly.hostname=$(oc get route management-remote-microprofile-config-bootable --template='{{ .spec.host }}') Check that the application is running properly : $ curl https://$(oc get route remote-microprofile-config-bootable --template='{{ .spec.host }}') config1 = Value from Config1 comes from an env var in the DeploymentConfig config2 = Value for config2 comes from a properties file inside the application config3 = Default value for config3 comes from my code Once this is done you can edit the code and your changes will be automatically pushed to the OpenShift instance. For example: * Change the config2 property value to be "Hello from dev-watch remote" in the file: src/main/resources/META-INF/microprofile-config.properties. * Save your changes * The application is redeployed and the new configuration will be taken into account: $ curl https://$(oc get route remote-microprofile-config-bootable --template='{{ .spec.host }}') config1 = Value from Config1 comes from an env var in the DeploymentConfig config2 = Hello from dev-watch remote config3 = Default value for config3 comes from my code CONCLUSION We hope that you are seeing the benefits of the new features that this release is bringing. We would really appreciate your on the dev-watch goal. We aim toward a smooth and efficient first class WildFly developer experience and we need you there! Thank-you.</content><dc:creator>Emmanuel Hugonnet</dc:creator></entry><entry><title>Kafka Monthly Digest: August 2022</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/09/13/kafka-monthly-digest-august-2022" /><author><name>Mickael Maison</name></author><id>195c9344-8250-48a9-9554-85515b7d00a9</id><updated>2022-09-13T07:00:00Z</updated><published>2022-09-13T07:00:00Z</published><summary type="html">&lt;p&gt;This 55th edition of the &lt;a href="https://developers.redhat.com/topics/kafka-kubernetes"&gt;Kafka&lt;/a&gt; Monthly Digest covers what happened in the &lt;a href="https://kafka.apache.org/"&gt;Apache Kafka&lt;/a&gt; community in August 2022.&lt;/p&gt; &lt;p&gt;For last month’s digest, see &lt;a href="https://developers.redhat.com/articles/2022/08/04/kafka-monthly-digest-july-2022"&gt;Kafka Monthly Digest: July 2022&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Releases&lt;/h2&gt; &lt;p&gt;There is currently one release in progress, 3.3.0.&lt;/p&gt; &lt;h3&gt;3.3.0&lt;/h3&gt; &lt;p&gt;The release process for 3.3.0 continued. José Armando García Sancio published the first release candidate on August 29. A few issues, including &lt;a href="https://issues.apache.org/jira/browse/KAFKA-14187"&gt;KAFKA-14187&lt;/a&gt; and &lt;a href="https://issues.apache.org/jira/browse/KAFKA-14156"&gt;KAFKA-14156&lt;/a&gt;, were found during testing, so José built RC1 on September 1. The vote is currently ongoing. You can find the &lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/Release+Plan+3.3.0"&gt;release plan&lt;/a&gt; in the wiki.&lt;/p&gt; &lt;h2&gt;Kafka Improvement Proposals&lt;/h2&gt; &lt;p&gt;Last month, the community submitted three &lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals"&gt;Kafka Improvement Proposals (KIPs)&lt;/a&gt; (KIP-863 to KIP-865). I'll highlight a couple of them:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-864%3A+Add+End-To-End+Latency+Metrics+to+Connectors"&gt;KIP-864: Add End-To-End Latency Metrics to Connectors&lt;/a&gt;. This KIP proposes adding a few new metrics to track end-to-end latency for records flowing through Connect. This would also include metrics tracking the time spent in converters.&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-865%3A+Support+--bootstrap-server+in+kafka-streams-application-reset"&gt;KIP-865: Support --bootstrap-server in kafka-streams-application-reset&lt;/a&gt;. This very small KIP aims at addressing a discrepancy with the &lt;code&gt;kafka-streams-application-reset.sh&lt;/code&gt; tool. This tool currently uses the &lt;code&gt;--bootstrap-servers&lt;/code&gt; flag, while all other tools use &lt;code&gt;--bootstrap-server&lt;/code&gt;, so it will be updated for consistency.&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Community releases&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://github.com/tchiotludo/akhq/releases/tag/0.22.0"&gt;akhq 0.22&lt;/a&gt;: AKHQ is a GUI for Apache Kafka. This new version adds a few new features, including support for listing ACLs on Cluster and TransactionalIds and sending Protobuf records via the UI.&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/tulios/kafkajs/releases/tag/v2.2.0"&gt;kafkajs 2.2.0&lt;/a&gt;: Kafkajs is a pure JavaScript Kafka client for Node.js. This release adds support for triggering and listing partition reassignments in its Admin API and contains a few fixes.&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Blogs&lt;/h2&gt; &lt;p&gt;I selected some interesting blog articles that were published last month:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://towardsdatascience.com/machine-learning-streaming-with-kafka-debezium-and-bentoml-c5f3996afe8f"&gt;Machine Learning Streaming with Kafka, Debezium, and BentoML&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://medium.com/event-driven-utopia/building-cqrs-views-with-debezium-kafka-materialize-and-apache-pinot-part-1-4f697735b2e4"&gt;Building CQRS Views with Debezium, Kafka, Materialize, and Apache Pinot — Part 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://medium.com/event-driven-utopia/building-cqrs-views-with-debezium-kafka-materialize-and-apache-pinot-part-2-6899e9efc74e"&gt;Building CQRS Views with Debezium, Kafka, Materialize, and Apache Pinot — Part 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;To learn more about Kafka, visit &lt;a href="https://developers.redhat.com/topics/kafka-kubernetes"&gt;Red Hat Developer's Apache Kafka topic page&lt;/a&gt;.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/09/13/kafka-monthly-digest-august-2022" title="Kafka Monthly Digest: August 2022"&gt;Kafka Monthly Digest: August 2022&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Mickael Maison</dc:creator><dc:date>2022-09-13T07:00:00Z</dc:date></entry></feed>
